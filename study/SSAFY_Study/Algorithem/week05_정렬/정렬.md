# 정렬

### 정렬을 하게되면 이후 이진 탐색이 가능해진다. 
    - 즉 이진 탐색의 전 처리 과정이기도 함.

1. 선택정렬
2. 삽입 정렬
3. 퀵 정렬
4. 계수 정렬
5. 머지(병합) 정렬


#### 리스트를 뒤집는 연산은 O(N)의 복잡도로도 간단히 가능함.

## 선택정렬
### 무작위의 데이터를 이 중에서 가장 작은 데이터를 선택해 맨  앞에 데이터와 바꾸고 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정 => 선택정렬
    - 이 방법은 가장 원시적인 방법으로 매번 가장 작은 것을 선택한다는 의미에서 선택 정렬 알고리즘 이라함.
    - 결과적으로 N - 1 번 반복하면 정렬이 완료된다.
    - 기본 정렬 라이브러리랑 비교했을때도 매우 비 효율적인 정렬임.

```python
array = [7, 2, 3, 1, 5]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i+_1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] #스왚
```

## 삽입 정렬
### 데이터를 하나씩 확인하며 각 데이터를 적절한 위치에 삽입해보는것.
    - 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞 까지의 데이터는 이미 정렬 되었다고 가정한다. 따라서 데이터 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입된다.
    - 삽입 정렬은 정렬이 이루어진 원소는 항상 오름차순을 유지한다.
    - 정렬이 거의 되어있는 상황에서는 퀵 정렬 알고리즘보다 더 강력할 수 있음.
         - 따라서 거의 정렬된 상타에 입력이 주어지는 문제면 퀵 정렬 등의 다른 알고리즘보다 삽입 정렬을 이용해야됨.

```python
array = [7, 2, 3, 1, 5]

for i in range(1, len(array)): # 삽입 정렬은 첫번째 요소는 적잘한 위치라고 가정하기에 1부터 시작.
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 감소하면서 반복하면됨.
        if array[j] < array[j-1]: # 한칸씩 왼쪽으로 이동.
            array[j], array[j-1] = array[j-1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그자리에 둬야하잖아? 
                # 즉 j가 array[j-1]보다 크면 이미 정렬된 상태이니 그냥 둬야지. 그래서 break하는거!
            break
print(array)
```

## 퀵 정렬
### 가장 많이 사용되는 알고리즘으로 기준 데이터를 설정하고, 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 과정
    - 아래 내용은 호어 분할 방식을 기준으로한 퀵 정렬임.
    1. 리스트에서 첫번째 데이터를 피벗으로 정함.
    2. 왼쪽부터 피벗보다 큰 데이터를 찾고, 오른쪽부터 피벗보다 작은 데이터를 찾은 후 서로 교환해준다.
    3. 해당과정을 반복해주면 되는데 이때에 재귀함수를 사용하게된다.
        - 재귀함수의 종료 조건은 리스트의 데이터 개수가 1개인 경우.
        - 리스트 원소가 1개면 이미 정렬 되어 있다고 간주할 수 있으며 분할이 불가능해짐.
    4. 이미 데이터가 정렬 되어있는 경우엔은 매우 느리게 동작한다.


```python
array = [5, 7 , 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소임
    left = start +1
    right = end
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때 까지 반복하기
        while left <= end and array[left] <= array[pivot]:
            left +=1
        # 피벗보다 작은 데이터를 찾을 때 까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if lect > right : # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else: #엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하기.
    quick_sort(array, start, right -1)
    quick_sort(array, right +1, end)

quick_sort(array, 0, len(array)-1)
print(array)

```

간단하게쓰면
```PYTHON
def quicksort(arr):
    if len(arr) <= 1:
        return arr  # 길이가 1 이하인 리스트는 이미 정렬됨
    
    pivot = arr[-1]  # 피벗 선택 (마지막 요소)
    left = [x for x in arr[:-1] if x <= pivot]  # 피벗보다 작은 요소들
    right = [x for x in arr[:-1] if x > pivot]  # 피벗보다 큰 요소들

    return quicksort(left) + [pivot] + quicksort(right)  # 재귀적으로 정렬 및 병합

# 정렬할 리스트
arr = [3, 7, 8, 5, 2, 1, 9, 6, 4, 0]
# 퀵소트 실행
sorted_arr = quicksort(arr)
print(sorted_arr)

```


## 계수 정럴(카운팅 정렬)
### 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
    - 1. 정수 형태로 표현할 수 있을 때만 사용가능하다.
        - 예를들어 데이터의 값이 무한한 범위를 가질 수 잇는 실수형 데이터가 주어지는경우, 계수 정렬은 사용하기 어렵다.
        - 대략 가장 큰데이터와 가장 작은 데이터의 차이가 100만을 넘지 않을때 효과적으로 사용해볼 수 있다.
        - 이유는: 계수 정렬을 이용할때에는 모든 범위를 담을 수 있는 크기의 리스트를 선언해야되기 때문이다.
    

```PYTHON
array = [7, 5, 9, 0 ,3, 1, 6, 2, 9, 1, 4, 9, 8, 0 ,5, 2]

count = [0] * (max(array)+1) # 생성하려는 배열의 최대값보다 1많게 선언.  0이들어가야되잖아!

for i in ragne(len(array)):
    count[array[i]] += 1 #  각 데이터에 해당하는 인덱스의 값 증가시켜주기

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인하기
    for j in range(count[i]): # 해당 리스트에 숫자만큼 전부 불러와야하잖아!
        print(i, end= ' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력하기
```


### 계수정렬의 공간 복잡도
- 심각한 비효율성을 초래할 수 있다. 
    - 예를들어 데이터가 0과 999,999 단 두개만 존재할때 100만개를 선언해야되기 때문이다.
- 따라서 데이터 크기가 한정되어 있고, 데이터 크기가 많이 중복되어있을수록 유리함.




# 라이브러리 정렬
## sorted
### 딕셔너리나, 집합, 리스트를 입력 받아도 반환되는 결화는 리스트 자료형이다.

## sort()
리스트 객체의 내장함수도 사용가능. 별도의 정렬된 리스트를 반환하지 않고 내부 원소가 바로 정렬됨.

### sorted나, ostr()는 매게변수 key 를 입력받을 수 있다.
- key 값으로는 하나의 함수가 들어가야하며 정렬 기준이 될 수 있음.
    - 예를들어 리스트 데이터가 튜플로 구성되어 있을대, 각 데이터의 두번째 원소를 기준으로 설정도 가능. 혹은 람다도 사용 가능.

```python
array [('바나나', 2), ('사과', 5), ('당근',3)]

def setting(data):
    return data[1]


result = sorted(array, key=setting)
print(result)
```

- 위와 같이 작성시
- [('바나나', 2),('당근',3) , ('사과', 5)] 와같이 2번째 요소를 기준으로 정렬 가능함. 기준점을 삼을 수 있다는 것임.